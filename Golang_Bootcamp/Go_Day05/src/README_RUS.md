# Day 05 - Go Boot camp

## Santa is back in town 

## Contents

1. [Chapter I](#chapter-i) \
    1.1. [General rules](#general-rules)
2. [Chapter II](#chapter-ii) \
    2.1. [Rules of the day](#rules-of-the-day)
3. [Chapter III](#chapter-iii) \
    3.1. [Intro](#intro)
4. [Chapter IV](#chapter-iv) \
    4.1. [Exercise 00: Toys on a Tree](#exercise-00-toys-on-a-tree)
5. [Chapter V](#chapter-v) \
    5.1. [Exercise 01: Decorating](#exercise-01-decorating)
6. [Chapter VI](#chapter-vi) \
    6.1. [Exercise 02: Heap of Presents](#exercise-02-heap-of-presents)
7. [Chapter VII](#chapter-vii) \
    7.1. [Exercise 03: Knapsack](#exercise-03-knapsack)
8. [Chapter VIII](#chapter-viii) \
    8.1. [Reading](#reading)


<h2 id="chapter-i" >Chapter I</h2>
<h2 id="general-rules" >General rules</h2>

- Ваши программы не должны завершать работу неожиданно (выдавая ошибку при правильном вводе). Если это произойдет, ваш проект будет считаться нефункциональным и при оценке получит 0 баллов.
- Мы рекомендуем вам создавать тестовые программы для вашего проекта, даже если эту работу не нужно будет отправлять и она не будет оцениваться. Это даст вам возможность легко проверить свою работу и работу своих коллег. Вы найдете эти тесты особенно полезными во время вашей защиты. Действительно, во время защиты вы можете использовать свои тесты и/или тесты коллеги, которого вы оцениваете.
- Отправьте свою работу в назначенный вам репозиторий git. Оцениваться будет только работа в репозитории git.
- Если ваш код использует внешние зависимости, для управления ими следует использовать [Go Modules](https://go.dev/blog/using-go-modules).

<h2 id="chapter-ii" >Chapter II</h2>
<h2 id="rules-of-the-day" >Rules of the day</h2>

- Вам следует сдавать только файлы `*.go` и (в случае внешних зависимостей) `go.mod` + `go.sum`
- Ваш код для этой задачи должен быть готов к сборке с помощью команды `go build`

<h2 id="chapter-iii" >Chapter III</h2>
<h2 id="intro" >Intro</h2>

&mdash; Я не знаю, - сказала Лиля. - Единственное, что я читал об этой штуке, которую древние чуваки называли "Рождество", - это то, что у тебя должна быть, типа, елка, что-то под названием "гирлянда" и, наконец, "куча подарков", что бы это ни значило.

Вы перемещаете козырек Neualink вниз, на шею.

&mdash; Да ладно, девочка, это просто городская легенда! Как вы думаете, почему сочетание таких простых вещей должно привести к чему-то интересному?

Она смотрела в потолок, мечтая.

&mdash; Раньше был такой старик в красной толстовке или типа того... Думаешь, он был одним из первых хакеров-бунтовщиков? Знаете, делиться со всеми быстрыми хаками? Значит, если бы сценаристы были в восторге от свободы и борьбы с корпорацией, они могли бы использовать свои «подарки» для взлома корпоративных брандмауэров?

&mdash; Да, кажется законным. Знаете, городские легенды подземелья имеют мистическую ауру. Скорее всего это был просто какой-нибудь бородатый энтузиаст открытого исходного кода. Какими бы безумными ни были сейчас люди, по крайней мере, никто не говорит что-то вроде «он ехал на антигравитационных санях, запряженных робо-оленями». Более вероятно, что у него был ботнет из переносимых [ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) двоичных файлов на корпоративных серверах, который собирал секретные материалы и бесплатно раздавал их людям.

Лили откинулась на диване и достала связку голограмм.

&mdash; Ладно, все знают, как выглядят деревья - над ее головой плавала куча 3д графиков без циклов - Какие из них нам нужны?

<h2 id="chapter-iv" >Chapter IV</h2>
<h3 id="ex00">Exercise 00: Toys on a Tree</h3>

Через некоторое время вы вдвоем собрали структуру узла [Binary tree](https://en.wikipedia.org/wiki/Binary_tree):

```go
type TreeNode struct {
    HasToy bool
    Left *TreeNode
    Right *TreeNode
}
```

&mdash; Похоже, тебе придётся... "вешать игрушки" на деревья? - Лили выглядела немного растерянной. - Хорошо, в любом случае, будем надеяться, что просто логического значения будет достаточно. Но говорят, что класть больше игрушек на одну сторону тоже неправильно, она должна быть единой?

&mdash; Хорошо, я понял, - сказал ты. — Напишем функцию `areToysBalanced()`, которая будет получать в качестве аргумента указатель на корень дерева. Суть в том, чтобы выдать логическое значение `true/false` в зависимости от того, содержит ли левое поддерево такое же количество игрушек, как и правое. Значение самого корня можно игнорировать.

Итак, ваша функция должна возвращать `true` для таких деревьев (0/1 представляет ложь/истину, равное количество единиц в обоих поддеревьях):

```
    0
   / \
  0   1
 / \
0   1
```

```
    1
   /  \
  1     0
 / \   / \
1   0 1   1
```

и `false` для таких деревьев (неравное количество единиц в обоих поддеревьях):

```
  1
 / \
1   0
```

```
  0
 / \
1   0
 \   \
  1   1
```

<h2 id="chapter-v" >Chapter V</h2>
<h3 id="ex01">Exercise 01: Decorating</h3>

&mdash; Итак, теперь об этой «гирлянде».. Ее полагается «наматывать» на елку.

Лили вращала голограмму взад и вперед, пытаясь о чем-то подумать. И вдруг она загорается энтузиазмом.

&mdash; Я понимаю! Давайте сделаем так... - она ​​рисует на вершине дерева что-то похожее на трехмерную змею.

Итак, теперь вам нужно написать еще одну функцию под названием unrollGarland(), которая также получает указатель на корневой узел. Идея состоит в том, чтобы идти сверху вниз, слой за слоем, переходя направо по четным горизонтальным слоям и слева по всем нечетным. Возвращаемое значение этой функции должно быть частью логических значений. Итак, для этого дерева:

```
    1
   /  \
  1     0
 / \   / \
1   0 1   1
```

Ответ будет [правда, правда, ложь, правда, правда, ложь, правда] (корень - правда, затем на втором уровне идем слева направо, а затем на третьем справа налево, как зигзаг).

<h2 id="chapter-vi" >Chapter VI</h2>
<h3 id="ex02">Exercise 02: Heap of Presents</h3>

&mdash; Идеальный! Понятия не имею, что эти старики имели в виду под «рождественской елкой», но думаю, мы выполнили общие требования.

&mdash; Итак, насчет этих «подарков»...

&mdash; Подарки, да! - Лили поднимает изящный палец с очень длинным фиолетовым ногтем. Он был специально усилен для борьбы с врагами и (гораздо чаще) для отвинчивания различных устройств. - Итак, давайте представим это как кучу. Каждый такой «подарочек» может выглядеть так:

```go
type Present struct {
    Value int
    Size int
}
```

&mdash; Хм, а что такое «ценность»?

&mdash; Ну, некоторые вещи вы склонны ценить больше, чем другие, верно? Поэтому они должны быть сопоставимы.

&mdash; Хорошо, а «Размер» — это то, сколько времени мне понадобится, чтобы его загрузить, верно?

&mdash; Точно! Итак, самое крутое должно быть сверху.

Вам необходимо реализовать структуру данных PresentHeap (рекомендуется использовать встроенную библиотеку «контейнер/куча», но это не является строго обязательным). Подарки сначала сравниваются по ценности (самый ценный подарок кладется сверху). *Только* в случае, если два подарка имеют одинаковую стоимость, меньший считается «круче» другого (выигрывает в сравнении).

Помимо самой структуры, вам следует реализовать функцию `getNCoolestPresents()`, которая по несортированному срезу Presents и целому числу `n` будет возвращать отсортированный срез (desc) самых «крутых» из списка. Он должен использовать внутри структуру данных PresentHeap и возвращать ошибку, если n больше размера среза или отрицательно.

Итак, если мы представим каждый Present кортежем из двух чисел (Значение, Размер), то для этого ввода:

```
(5, 1)
(4, 5)
(3, 1)
(5, 2)
```

двумя «самыми крутыми» подарками будут [(5, 1), (5, 2)], потому что первый из них имеет меньший размер из двух со значением = 5.

<h2 id="chapter-vii" >Chapter VII</h2>
<h3 id="ex03">Exercise 03: Knapsack</h3>

&mdash; Ждать! - Вы сказали. - Но откуда мне знать, что все эти замечательные подарки не займут все место на моем жестком диске?

Лили на мгновение задумалась, но затем предложила:

&mdash; В таком случае давайте скачивать только самые ценные подарки!

&mdash; Но Heap использует другой порядок и здесь нам не поможет...

&mdash; Правда правда. В любом случае, должен быть какой-то аргумент, чтобы выяснить, как получить максимальную отдачу от имеющегося у вас пространства, верно?

...В КиберСити выдалась замечательная зимняя ночь. Несмотря на то, что за последние столетия традиции сильно изменились, у вас двоих было ощущение, что вы все сделали правильно. А еще Лили еще не знала о новой крутой портативной кибердеке, которую вы приготовили ей в подарок сегодня вечером. И ты понятия не имел, что находится в этой маленькой загадочной коробочке на ее столе.

В качестве последней задачи вам необходимо реализовать классический алгоритм динамического программирования, также известный как «Задача о рюкзаке». Ввод почти такой же, как и в последнем задании — у вас есть слайс подарков, каждый со значением и размером, но на этот раз у вас также есть жесткий диск с ограниченной емкостью. Итак, вам нужно выбирать только те подарки, которые соответствуют этой вместимости, и максимизировать полученную ценность.

Пожалуйста, напишите функцию `grabPresents()`, которая получает слайс Present и емкость вашего жесткого диска. На выходе эта функция должна выдать еще один слайс Presents, который должен иметь максимальное совокупное Value, которое вы можете получить с такой емкостью (capacity).

<h2 id="chapter-viii" >Chapter VIII</h2>
<h3 id="reading">Reading</h3>

[Binary Tree](https://en.wikipedia.org/wiki/Binary_tree)
[Breadth-First Search](https://en.wikipedia.org/wiki/Breadth-first_search)
[Depth-First Search](https://en.wikipedia.org/wiki/Depth-first_search)
[Recursion in Go](https://www.tutorialspoint.com/go/go_recursion.htm)
[Heap](https://en.wikipedia.org/wiki/Heap_(data_structure))
[Heap implementation in Go](https://golang.org/pkg/container/heap/)
[Knapsack Problem](https://en.wikipedia.org/wiki/Knapsack_problem)
[Multi-Dimensional arrays and slices in Go](https://golangbyexample.com/two-dimensional-array-slice-golang/)

