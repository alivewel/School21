# Day 01 - Go Intensive

## Comparing Incomparable

## Contents

1. [Chapter I](#chapter-i) \
    1.1. [General rules](#general-rules)
2. [Chapter II](#chapter-ii) \
    2.1. [Rules of the day](#rules-of-the-day)
3. [Chapter III](#chapter-iii) \
    3.1. [Intro](#intro)
4. [Chapter IV](#chapter-iv) \
    4.1. [Exercise 00: Reading](#exercise-00-reading)
5. [Chapter V](#chapter-v) \
    5.1. [Exercise 01: Assessing Damage](#exercise-01-assessing-damage)
6. [Chapter VI](#chapter-vi) \
    6.1. [Exercise 02: Afterparty](#exercise-02-afterparty)


<h2 id="chapter-i" >Chapter I</h2>
<h2 id="general-rules" >General rules</h2>

- Ваши программы не должны завершать работу неожиданно (выдавая ошибку при правильном вводе). Если это произойдет, ваш проект будет считаться нефункциональным и при оценке получит 0 баллов.
- Мы рекомендуем вам создавать тестовые программы для вашего проекта, даже если эту работу не нужно будет отправлять и она не будет оцениваться. Это даст вам возможность легко проверить свою работу и работу своих коллег. Вы найдете эти тесты особенно полезными во время вашей защиты. Действительно, во время защиты вы можете использовать свои тесты и/или тесты коллеги, которого вы оцениваете.
- Отправьте свою работу в назначенный вам репозиторий git. Оцениваться будет только работа в репозитории git.
- Если ваш код использует внешние зависимости, для управления ими следует использовать [Go Modules](https://go.dev/blog/using-go-modules).

<h2 id="chapter-ii" >Chapter II</h2>
<h2 id="rules-of-the-day" >Rules of the day</h2>

- Вам следует сдавать только файлы `*.go` и (в случае внешних зависимостей) `go.mod` + `go.sum`
- Ваш код для этой задачи должен быть готов к сборке с помощью команды `go build`.

<h2 id="chapter-iii" >Chapter III</h2>
<h2 id="intro" >Intro</h2>

В мире программирования и Go в частности существует множество популярных форматов данных. Но весьма вероятно, что вы встретите один из них на своем пути — XML или JSON.
Множество API используют JSON и/или XML для кодирования структурированных данных.

И... иногда даже пекарни используют их для хранения рецептов. Итак, старая знаменитая пекарня в Вилларибе всегда использовала старый добрый XML для хранения списка рецептов тортов. Если мы посмотрим на часть этой базы данных, она будет выглядеть примерно так:

```xml
<recipes>
    <cake>
        <name>Red Velvet Strawberry Cake</name>
        <stovetime>40 min</stovetime>
        <ingredients>
            <item>
                <itemname>Flour</itemname>
                <itemcount>3</itemcount>
                <itemunit>cups</itemunit>
            </item>
            <item>
                <itemname>Vanilla extract</itemname>
                <itemcount>1.5</itemcount>
                <itemunit>tablespoons</itemunit>
            </item>
            <item>
                <itemname>Strawberries</itemname>
                <itemcount>7</itemcount>
                <itemunit></itemunit> <!-- itemunit may be empty  -->
            </item>
            <!-- Here can be more ingredients  -->
        </ingredients>
    </cake>
    <cake>
        <name>Blueberry Muffin Cake</name>
        <stovetime>30 min</stovetime>
        <ingredients>
            <item>
                <itemname>Baking powder</itemname>
                <itemcount>3</itemcount>
                <itemunit>teaspoons</itemunit>
            </item>
            <item>
                <itemname>Brown sugar</itemname>
                <itemcount>0.5</itemcount>
                <itemunit>cup</itemunit>
            </item>
            <item>
                <itemname>Blueberries</itemname>
                <itemcount>1</itemcount>
                <itemunit>cup</itemunit>
            </item>
            <!-- Here can be more ingredients  -->
        </ingredients>
    </cake>
    <!-- Here can be more cakes  -->
</recipes>
```

Жизнь была прекрасной и простой, пока владелец пекарни не узнал, что в соседней деревне, Виллабахо, теперь живет грязный самозванец, умудрившийся украсть его рецепты! Чтобы сойти с рук за свой обман, он даже использовал другой формат данных, чтобы сохранить их и скрыться от правосудия!

```json
{
  "cake": [
    {
      "name": "Red Velvet Strawberry Cake",
      "time": "45 min",
      "ingredients": [
        {
          "ingredient_name": "Flour",
          "ingredient_count": "2",
          "ingredient_unit": "mugs"
        },
        {
          "ingredient_name": "Strawberries",
          "ingredient_count": "7"  // ingredient_unit is not even here!
        },
        {
          "ingredient_name": "Vanilla extract",
          "ingredient_count": "2.5",
          "ingredient_unit": "tablespoons"
        }
      ]
    },
    {
      "name": "Blueberry Muffin Cake",
      "time": "30 min",
      "ingredients": [
        {
          "ingredient_name": "Brown sugar",
          "ingredient_count": "1",
          "ingredient_unit": "mug"
        },
        {
          "ingredient_name": "Blueberries",
          "ingredient_count": "1",
          "ingredient_unit": "mug"
        }
      ]
    }
  ]
}
```

Он не мог не заметить, что вор не только украл его рецепты, но и изменил некоторые из них. Некоторые ингредиенты отсутствовали, количество было изменено, единицы переименованы. Итак, он приготовился к мести!


<h2 id="chapter-iv" >Chapter IV</h2>
<h3 id="ex00">Exercise 00: Reading</h3>

Прежде всего, ему нужно было научиться читать базу данных. У владельца уже был CLI, поэтому он решил, что чтение файла должно быть простым, поэтому оба варианта должны работать (для простоты файлы можно различать по расширению):

`~$ ./readDB -f original_database.xml`
`~$ ./readDB -f stolen_database.json`

]Мало того, он также решил, что чтение обоих файлов не должно составить труда через один и тот же интерфейс, который он назвал «DBReader». Это означает, что чтение разных форматов означает, что у нас есть разные *реализации* одного и того же интерфейса `DBReader`, который в результате должен выдавать одни и те же типы объектов, независимо от того, читается ли оно из исходной базы данных или из украденной. Да, его идея состоит в том, чтобы выбрать подходящую реализацию на основе расширения файла.

Итак, вам нужно помочь ему в этом. Подумайте, какие типы объектов есть в этих базах данных и как их можно представить в коде. Затем напишите интерфейс DBReader и две его реализации — одну для чтения JSON и одну для чтения XML. Оба они должны в результате вернуть объект одного и того же типа.

Чтобы проверить, работает ли его идея, заставьте код печатать версию базы данных в формате JSON при чтении из XML и наоборот. Поля XML и JSON должны иметь отступы в 4 пробела («pretty-printing»).

<h2 id="chapter-v" >Chapter V</h2>
<h3 id="ex01">Exercise 01: Assessing Damage</h3>

Ладно, теперь владелец решил сравнить базы. Вы видели, что украденная база данных содержит модифицированные версии одних и тех же рецептов, а это означает, что существует несколько возможных случаев:

1) Добавляется новый торт или удаляется старый
2) Время приготовления одного и того же торта разное.
3) В тот же торт добавляется или удаляется новый ингредиент. *Важно:* порядок ингредиентов не имеет значения. Есть только имена.
4) Изменилось количество единиц одного и того же ингредиента.
5) Изменилась сама единица измерения ингредиента.
6) Единица ингредиента отсутствует или добавлена.

Быстро просмотрев базу данных, владелец также заметил, что никто не удосужился переименовать торты или ингредиенты (возможно, просто добавил несколько новых), поэтому можно предположить, что имена в обеих базах одинаковы.

Ваше приложение должно запускаться следующим образом:

`~$ ./compareDB --old original_database.xml --new stolen_database.json`

Он должен работать с обоими форматами (JSON и XML) для исходной и новой базы данных, повторно используя код из Exercise 00.

Вывод должен выглядеть следующим образом (те же случаи, которые описаны выше):

```
ADDED cake "Moonshine Muffin"
REMOVED cake "Blueberry Muffin Cake"
CHANGED cooking time for cake "Red Velvet Strawberry Cake" - "45 min" instead of "40 min"
ADDED ingredient "Coffee beans" for cake  "Red Velvet Strawberry Cake"
REMOVED ingredient "Vanilla extract" for cake  "Red Velvet Strawberry Cake"
CHANGED unit for ingredient "Flour" for cake  "Red Velvet Strawberry Cake" - "mugs" instead of "cups"
CHANGED unit count for ingredient "Vanilla extract" for cake  "Red Velvet Strawberry Cake" - "2.5" instead of "1.5"
REMOVED unit "tablespoons" for ingredient "Vanilla extract" for cake  "Red Velvet Strawberry Cake"
```
```
ДОБАВЛЕН торт "Самогонный маффин"
УДАЛЕНО торт "Маффин с черникой"
ИЗМЕНЕНО время приготовления торта «Клубничный торт «Красный бархат»» - «45 минут» вместо «40 минут».
ДОБАВЛЕН ингредиент "Кофе в зернах" для торта "Клубничный торт Красный бархат"
УДАЛЕН ингредиент «Экстракт ванили» для торта «Клубничный торт «Красный бархат»»
ИЗМЕНЕНА единица ингредиента "Мука" для торта "Клубничный торт "Красный бархат"" - вместо "чашек" - "кружочки"
ИЗМЕНЕНО количество единиц ингредиента «Ванильный экстракт» для торта «Клубничный торт «Красный бархат»» - «2,5» вместо «1,5».
УДАЛЕНА единица «столовые ложки» для ингредиента «Ванильный экстракт» для торта «Клубничный торт «Красный бархат»».
```

<h2 id="chapter-vi" >Chapter VI</h2>
<h3 id="ex02">Exercise 02: Afterparty</h3>

Покопавшись в базе данных, владелец пекарни Виллариба вдруг понял — этот парень гениален! Некоторые рецепты были значительно улучшены по сравнению со старой версией, и эти новые идеи были действительно креативными! Он ворвался в Виллабахо и нашел парня, который, как он сначала подумал, украл его самое драгоценное наследие.

...В тот же вечер в кабаке два старых булочника обнимались, пили и смеялись так сильно, что это было слышно в обеих деревнях. За последние пару часов они стали лучшими друзьями, и каждый из них был очень рад наконец найти человека, который мог бы болтать всю ночь о тортах! Также выяснилось, что парень не украл базу данных, он просто пытался угадать на вкус и немного поимпровизировать.

После всей этой путаницы они оба согласились использовать ваш код, но попросили вас выполнить для них последнее задание. Они были весьма впечатлены тем, как вам удалось провести сравнение между базами данных, поэтому они также попросили вас сделать то же самое с резервными копиями файловой системы их серверов, чтобы ни одна пекарня не столкнулась с какими-либо техническими проблемами в будущем.

Итак, ваша программа должна сделать два дампа файловой системы.

`~$ ./compareFS --old snapshot1.txt --new snapshot2.txt`

Оба файла представляют собой обычные текстовые файлы, не отсортированные, и каждый из них включает в себя путь к файлу, например:

```
/etc/stove/config.xml
/Users/baker/recipes/database.xml
/Users/baker/recipes/database_version3.yaml
/var/log/orders.log
/Users/baker/pokemon.avi
```

Ваш инструмент должен вывести результат, очень похожий на предыдущий код (правда, без случая CHANGED):

```
ADDED /etc/systemd/system/very_important/stash_location.jpg
REMOVED /var/log/browser_history.txt
```

Однако есть одна проблема: файлы могут быть очень большими, поэтому можно предположить, что оба они не поместятся в оперативную память одновременно. Есть два возможных способа преодолеть это - либо каким-то образом сжать файл в памяти, либо просто прочитать один из них, а затем не читать другой. **Примечание:** на самом деле это очень популярный вопрос на собеседованиях.
