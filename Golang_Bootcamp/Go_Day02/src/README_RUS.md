# Day 02 - Go Intensive

## Not Invented Here Syndrome

## Contents

1. [Chapter I](#chapter-i) \
    1.1. [General rules](#general-rules)
2. [Chapter II](#chapter-ii) \
    2.1. [Rules of the day](#rules-of-the-day)
3. [Chapter III](#chapter-iii) \
    3.1. [Intro](#intro)
4. [Chapter IV](#chapter-iv) \
    4.1. [Exercise 00: Finding Things](#exercise-00-finding-things)
5. [Chapter V](#chapter-v) \
    5.1. [Exercise 01: Counting Things](#exercise-01-counting-things)
6. [Chapter VI](#chapter-vi) \
    6.1. [Exercise 02: Running Things](#exercise-02-running-things)
7. [Chapter VII](#chapter-vii) \
    7.1. [Exercise 03: Archiving Things](#exercise-03-archiving-things)


<h2 id="chapter-i" >Chapter I</h2>
<h2 id="general-rules" >General rules</h2>

- Ваши программы не должны завершать работу неожиданно (выдавая ошибку при правильном вводе). Если это произойдет, ваш проект будет считаться нефункциональным и при оценке получит 0 баллов.
- Мы рекомендуем вам создавать тестовые программы для вашего проекта, даже если эту работу не нужно будет отправлять и она не будет оцениваться. Это даст вам возможность легко проверить свою работу и работу своих коллег. Вы найдете эти тесты особенно полезными во время вашей защиты. Действительно, во время защиты вы можете использовать свои тесты и/или тесты коллеги, которого вы оцениваете.
- Отправьте свою работу в назначенный вам репозиторий git. Оцениваться будет только работа в репозитории git.
- Если ваш код использует внешние зависимости, для управления ими следует использовать [Go Modules](https://go.dev/blog/using-go-modules).

<h2 id="chapter-ii" >Chapter II</h2>
<h2 id="rules-of-the-day" >Общие правила</h2>

- Вам следует сдавать только файлы `*.go` и (в случае внешних зависимостей) `go.mod` + `go.sum`
- Ваш код для этой задачи должен быть готов к сборке с помощью команды go build.

<h2 id="chapter-iii" >Chapter III</h2>
<h2 id="intro" >Intro</h2>

Просто удивительно, как много можно сделать, просто используя утилиты командной строки! Практически любая ОС, включая встраиваемые, имеет собственный интерфейс командной строки и набор небольших программ, позволяющих творить чудеса. В качестве примера вы можете прочитать о [BusyBox](https://en.wikipedia.org/wiki/BusyBox), который по сути представляет собой швейцарский армейский нож для различных систем, начиная с маршрутизаторов под управлением Linux на OpenWRT и заканчивая на телефоны Android.

Мы не пытаемся изобретать велосипед, но знание того, как работать с FS и выполнять базовые операции CLI в Golang, может быть очень полезным, поэтому давайте потратим на это некоторое время.

<h2 id="chapter-iv" >Chapter IV</h2>
<h3 id="ex00">Exercise 00: Finding Things (Поиск предметов<)</h3>

В качестве первого шага давайте реализуем утилиту, подобную `find`, используя Go. Он должен принять некоторый путь и набор параметров командной строки, чтобы иметь возможность находить различные типы записей. Нас интересуют три типа записей: каталоги, обычные файлы и символические ссылки. Итак, мы сможем запустить нашу программу следующим образом:

```
# Finding all files/directories/symlinks recursively in directory /foo
~$ ./myFind /foo
/foo/bar
/foo/bar/baz
/foo/bar/baz/deep/directory
/foo/bar/test.txt
/foo/bar/buzz -> /foo/bar/baz
/foo/bar/broken_sl -> [broken]
```

или указав `-sl`, `-d` or `-f` для печати только символических ссылок, только каталогов или только файлов. Имейте в виду, что пользователь должен иметь возможность явно указать один, два или все три из них, например `./myFind -f -sl /path/to/dir` или `./myFind -d /path/to/other/dir`.

Вам также следует реализовать еще одну опцию - `-ext` (работает ТОЛЬКО если указан -f), чтобы пользователь мог печатать только файлы с определенным расширением. Расширением в этой задаче можно считать последнюю часть имени файла, если разделить ее точкой. Так,

```
# Finding only *.go files ignoring all the rest.
~$ ./myFind -f -ext 'go' /go
/go/src/github.com/mycoolproject/main.go
/go/src/github.com/mycoolproject/magic.go
```

Вам также необходимо разрешить символические ссылки. Итак, если `/foo/bar/buzz` является символической ссылкой, указывающей на какое-то другое место в FS, например `/foo/bar/baz`, выведите оба пути, разделенные `->`, как в примере выше.

Еще одна особенность символических ссылок заключается в том, что они могут быть повреждены (указывая на несуществующий файловый узел). В этом случае ваш код должен печатать `[broken]` вместо пути к месту назначения символической ссылки.

Файлы и каталоги, к которым у текущего пользователя нет доступа (ошибки разрешений), должны быть пропущены при выводе и не приводить к ошибке во время выполнения.

<h2 id="chapter-v" >Chapter V</h2>
<h3 id="ex01">Exercise 01: Counting Things (Счет вещей)</h3>

Теперь мы можем найти наши файлы, но нам может понадобиться дополнительная метаинформация о том, что находится в этих файлах. Давайте реализуем утилиту типа wc для сбора базовой статистики о наших файлах.

Перво-наперво, давайте предположим, что наши файлы представляют собой текстовые файлы в кодировке utf-8, поэтому ваш код должен работать и с текстами на русском языке (забудьте пока об особых случаях, таких как арабский, требуются только английский и русский). Кроме того, вы можете игнорировать знаки препинания и рассматривать пробелы как единственные разделители слов.

Вам потребуется реализовать три взаимоисключающих (за один раз можно указать только один, иначе выводится сообщение об ошибке) флага для вашего кода: `-l` для подсчета строк, `-m` для подсчета символов и `-w ` для подсчета слов. Ваша программа должна работать следующим образом:

```
# Counting words in file input.txt
~$ ./myWc -w input.txt
777 input.txt
# Counting lines in files input2.txt and input3.txt
~$ ./myWc -l input2.txt input3.txt
42 input2.txt
53 input3.txt
# Counting characters in files input4.txt, input5.txt and input6.txt
~$ ./myWc -m input4.txt input5.txt input6.txt
1337 input4.txt
2664 input5.txt
3991 input6.txt
```

Как видите, ответом всегда является вычисленное число и имя файла, разделенное табуляцией (`\t`). Если флаги не указаны, следует использовать поведение `-w`.

**Важно**: поскольку все файлы независимы, вам следует использовать горутины для их одновременной обработки. Вы можете запустить столько горутин, сколько входных файлов указано для программы.

<h2 id="chapter-vi" >Chapter VI</h2>
<h3 id="ex02">Exercise 02: Running Things (Управление делами)</h3>

Знаете ли вы, что такое xargs? Вы можете прочитать об этом, например, [здесь](https://shapeshed.com/unix-xargs/). Давайте реализуем аналогичный инструмент — в этом упражнении вам нужно будет написать утилиту, которая будет:

1) рассматривать все параметры как команду, например «wc -l» или «ls -la»
2) создайте команду, добавив все строки, которые подаются в стандартный ввод программы в качестве аргументов этой команды, а затем выполните ее. Итак, если мы запустим

```
~$ echo -e "/a\n/b\n/c" | ./myXargs ls -la
```

это должно быть эквивалентно запуску

```
~$ ls -la /a /b /c
```

Вы можете протестировать этот инструмент вместе с инструментами из предыдущих упражнений, поэтому

```
~$ ./myFind -f -ext 'log' /path/to/some/logs | ./myXargs ./myWc -l
```

будет рекурсивно рассчитывать количество строк для всех файлов «.log» в каталоге `/path/to/some/logs`.

<h2 id="chapter-vii" >Chapter VII</h2>
<h3 id="ex03">Exercise 03: Archiving Things (Архивирование)</h3>

Последний инструмент, который мы реализуем в этот день, — это инструмент ротации журналов. «Ротация журналов» — это процесс, при котором старый файл журнала архивируется и помещается на хранение, чтобы журналы не накапливались в одном файле бесконечно. Это должно работать следующим образом:

```
# Will create file /path/to/logs/some_application_1600785299.tag.gz
# where 1600785299 is a UNIX timestamp made from `some_application.log`'s [MTIME](https://linuxize.com/post/linux-touch-command/)
~$ ./myRotate /path/to/logs/some_application.log
```

```
# Создать файл /path/to/logs/some_application_1600785299.tag.gz
# где 1600785299 - это временная метка UNIX, полученная из [MTIME] `some_application.log` (https://linuxize.com/post/linux-touch-command/)
~$ ./myRotate /путь/к/журналам/some_application.log
```

```
# Will create two tar.gz files with timestamps (one for every log) 
# and put them into /data/archive directory
~$ ./myRotate -a /data/archive /path/to/logs/some_application.log /path/to/logs/other_application.log
```

```
# Создадим два файла tar.gz с временными метками (по одному для каждого журнала)
# и поместите их в каталог /data/archive
~$ ./myRotate -a /data/archive /path/to/logs/some_application.log /path/to/logs/other_application.log
```

Как и в упражнении 01, вам следует использовать горутины для параллельного архивирования нескольких файлов одновременно.
